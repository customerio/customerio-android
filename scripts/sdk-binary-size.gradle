import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import io.customer.android.Configurations

// Array of module names for evaluating SDK binary size
final List<String> targetModules = ['sdk', 'messagingpush', 'messaginginapp']
// Output file name for the combined report
final String sdkSizeReportFileName = 'sdk-binary-size.json'
// Unit used for generating binary size report
final String sdkSizeUnit = 'MB'

// Task to generate combined report of binary sizes of all SDK modules
// The report is generated in JSON format using apkscale plugin and is saved to
// `$buildDir/sdk-binary-size.json` by default
// This task can be run locally by executing `./gradlew generateSdkSizeReport`
// Run `./gradlew generateSdkSizeReport -PoutputDir=<outputDir>` to specify custom output directory
tasks.register("generateSdkSizeReport") {
    // List all task dependencies for each library module
    ArrayList<String> taskDependencies = targetModules.collect { String moduleName ->
        ":$moduleName:measureSize"
    }
    // Add the republishing task as the first dependency as temporary workaround to make it work locally
    if (System.getenv('IS_DEVELOPMENT') == "true") {
        taskDependencies.add(0, ':republishTrackingModuleAsSdk')
    }
    dependsOn(taskDependencies)

    doLast {
        JsonSlurper jsonSlurper = new JsonSlurper()
        Map<String, Object> reports = new HashMap<>()

        // Iterate over the target modules and read the apkscale report for each
        project.subprojects.findAll { Project subproject ->
            targetModules.contains(subproject.name)
        }.each { Project subproject ->
            // Get the path to the apkscale report for the module
            File jsonFile = subproject.file('build/apkscale/build/outputs/reports/apkscale.json')
            println "Checking for report at ${project.relativePath(jsonFile)}"

            // Parse the JSON file and extract module name and its binary size
            if (jsonFile.exists()) {
                def output = jsonSlurper.parseText(jsonFile.text).get(0)
                reports.put(subproject.name, output.size)
            } else {
                println "apkscale.json not found for ${subproject.name}"
            }
        }

        // Output directory for the combined report, default to `build` directory
        String outputDirectory = project.hasProperty('outputDir') ? project.getProperty('outputDir') : "$buildDir"
        // Create a combined report of all the individual reports
        File finalReport = project.file("$outputDirectory/$sdkSizeReportFileName")
        // Create parent directories if they do not exist
        finalReport.parentFile.mkdirs()
        // Write the combined report to output file as pretty printed JSON
        finalReport.text = new JsonBuilder(reports).toPrettyString()

        println "SDK binary size report successfully generated and saved to ${finalReport.canonicalPath}"
    }
}

// Task to compare the generated SDK binary size report with an existing report
tasks.register('compareSdkSizeReports') {
    // Ensure the comparison runs after the generation of the latest report
    dependsOn([':generateSdkSizeReport'])

    // Default directories for existing and generated reports
    String existingReportDirectory = "reports"
    String generatedReportDirectory = "$buildDir"

    // Allow overriding the directories from the command line to facilitate CI actions
    doFirst {
        if (project.hasProperty('existingReportDir')) {
            existingReportDirectory = project.property('existingReportDir')
        }
        if (project.hasProperty('generatedReportDir')) {
            generatedReportDirectory = project.property('generatedReportDir')
        }
    }

    doLast {
        // Read the existing and generated reports for comparison
        def existingReport = new JsonSlurper().parse(new File("$existingReportDirectory/$sdkSizeReportFileName"))
        def generatedReport = new JsonSlurper().parse(new File("$generatedReportDirectory/$sdkSizeReportFileName"))

        // Generates a base template for the comparison report and returns StringBuilder
        Closure<StringBuilder> initReportBuilder = {
            StringBuilder builder = new StringBuilder()
            builder << "## üìè SDK Binary Size Comparison Report\n\n"
            return builder
        }

        // Flag to indicate if any changes were detected in the comparison
        Boolean changesDetected = false
        StringBuilder output = initReportBuilder()

        // Generate a markdown table for the comparison report
        output << "| Module | Variant | Last Recorded Size | Current Size | Change in Size |\n"
        output << "| ------ | ------- | ----------------- | ----------- | ----------- |\n"

        // Closure to parse size string and extract the number
        Closure<Float> parseSize = { sizeStr ->
            sizeStr.replace(sdkSizeUnit, "").trim() as float
        }

        // Closure to compare the sizes of a module and variant
        Closure<StringBuilder> compareReport = { String moduleName, String variant ->
            // Get the size of the module and variant from existing and generated reports
            def existingSize = existingReport[moduleName]?[variant]
            def generatedSize = generatedReport[moduleName]?[variant]

            // Parse the size strings to extract comparable numbers
            float existingSizeAsNumber = existingSize ? parseSize(existingSize) : 0
            float generatedSizeAsNumber = generatedSize ? parseSize(generatedSize) : 0

            String sizeChangeSummary
            if (existingSizeAsNumber != generatedSizeAsNumber) {
                // Calculate the difference in size and format it with the unit
                changesDetected = true
                float changeInSize = generatedSizeAsNumber - existingSizeAsNumber
                String changeInSizeWithUnit = "${String.format("%.2f", changeInSize)}${sdkSizeUnit}"
                sizeChangeSummary = changeInSize > 0 ? "‚¨ÜÔ∏è +$changeInSizeWithUnit" : "‚¨áÔ∏è $changeInSizeWithUnit"
            } else {
                // If the sizes are the same, indicate no change
                sizeChangeSummary = "‚úÖ No Change"
            }
            // Append the comparison result to the output table
            output << "| `$moduleName` | `$variant` | `${existingSize}` | `${generatedSize}` | $sizeChangeSummary |\n"
        }

        // Iterate over the target modules and compare the sizes of universal variant,
        // as we are not tracking multiple abi variants for now
        targetModules.forEach { String moduleName ->
            compareReport(moduleName, 'universal')
        }

        // If no changes were detected, update the output to indicate no changes
        if (!changesDetected) {
            output = initReportBuilder()
            output << "No changes detected in SDK binary size. ‚úÖ\n"
        }

        // Output file for the comparison report at same location as the generated report
        File comparisonOutputFile = new File("$generatedReportDirectory/sdk-binary-comparison.md")
        // Write comparison results to the specified output file
        comparisonOutputFile.text = output.toString()

        println "Comparison completed. Results saved to: ${comparisonOutputFile.canonicalPath}"
    }
}

// This runs only in development mode locally and not in CI
// This is temporary and will be removed once tracking module is placed in same as its artifactId
//
// Republish the `tracking` module to `sdk` as a temporary workaround to track binary size
// The tracking module exists in directory named 'sdk', we need to republish 'tracking' as 'sdk'
// so apkscale can locate it locally
tasks.register("republishTrackingModuleAsSdk") {
    doLast {
        Boolean isDevelopment = System.getenv('IS_DEVELOPMENT') == "true"
        if (!isDevelopment) {
            println "Skipping republishing of the tracking module as SDK"
            return
        }

        println "Republishing the tracking module as SDK"

        String localMavenRepoPath = "${System.getProperty('user.home')}/.m2/repository"
        String groupPath = Configurations.artifactGroup.replace('.', '/')
        String sourceArtifactId = 'tracking'
        String destinationArtifactId = 'sdk'

        // Recursively copy and modify files
        def sourceArtifact = new File("$localMavenRepoPath/$groupPath/$sourceArtifactId")
        sourceArtifact.eachFileRecurse { File file ->
            String destinationFilePath = file.getPath().replace(sourceArtifactId, destinationArtifactId)
            File destinationFile = new File(destinationFilePath)

            // Ensure the destination directory exists before copying
            if (file.isDirectory()) {
                destinationFile.mkdirs()
            } else if (file.isFile()) {
                // Modify the contents of text files if they are XML, POM, or module files
                if (destinationFilePath.endsWith('.xml') || destinationFilePath.endsWith('.pom') || destinationFilePath.endsWith('.module')) {
                    String content = file.text.replace(sourceArtifactId, destinationArtifactId)
                    new File(destinationFilePath).write(content)
                } else {
                    // Else, copy the file as is and rename it
                    copy {
                        from file.path
                        into destinationFile.parentFile
                        rename { String fileName ->
                            return fileName.replace(sourceArtifactId, destinationArtifactId)
                        }
                    }
                }
            }
        }
    }
}
