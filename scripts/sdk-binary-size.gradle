import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import io.customer.android.Configurations

// This task generates a combined report of binary sizes of all SDK modules
// The report is generated in JSON format using apkscale plugin and is saved to `reports/sdk-binary-size.json`
// This task can be run locally by executing `./gradlew generateSdkSizeReport`
tasks.register("generateSdkSizeReport") {
    List<String> taskDependencies = [
            ':republishTrackingModuleAsSdk',
            ':sdk:measureSize',
            ':messagingpush:measureSize',
            ':messaginginapp:measureSize',
    ]
    dependsOn(taskDependencies)

    doLast {
        JsonSlurper jsonSlurper = new JsonSlurper()
        List<String> reportOutputs = []

        // Iterate over each library module and read the apkscale report
        project.subprojects.findAll { subproject ->
            subproject.plugins.hasPlugin('com.android.library')
        }.each { subproject ->
            println "Processing module: ${subproject.name}"

            // Read the apkscale report for the library module
            File jsonFile = subproject.file('build/apkscale/build/outputs/reports/apkscale.json')
            println "Checking for report at ${project.relativePath(jsonFile)}"

            // If the report exists, parse it and add it to the list
            if (jsonFile.exists()) {
                def output = jsonSlurper.parseText(jsonFile.text).get(0)
                Map<String, Object> report = [
                        library: output.library,
                        sizes  : output.size
                ]
                reportOutputs.add(report)
            } else {
                println "apkscale.json not found for ${subproject.name}"
            }
        }

        // Create a combined report of all the individual reports
        File outputFile = project.file('reports/sdk-binary-size.json')
        // Create the parent directory if it doesn't exist
        outputFile.parentFile.mkdir()
        // Write the combined report to output file as pretty printed JSON
        outputFile.text = new JsonBuilder(reportOutputs).toPrettyString()

        println "SDK binary size report successfully generated and saved to ${project.relativePath(outputFile)}"
    }
}

// This runs only in development mode locally and not in CI
// This is temporary and will be removed once tracking module is placed in same as its artifactId
//
// Republish the `tracking` module to `sdk` as a temporary workaround to track binary size
// The tracking module exists in directory named 'sdk', we need to republish 'tracking' as 'sdk'
// so apkscale can locate it locally
tasks.register("republishTrackingModuleAsSdk") {
    doLast {
        Boolean isDevelopment = System.getenv('IS_DEVELOPMENT') == "true"
        if (!isDevelopment) {
            println "Skipping republishing of the tracking module as SDK"
            return
        }

        println "Republishing the tracking module as SDK"

        String localMavenRepoPath = "${System.getProperty('user.home')}/.m2/repository"
        String groupPath = Configurations.artifactGroup.replace('.', '/')
        String sourceArtifactId = 'tracking'
        String destinationArtifactId = 'sdk'

        // Recursively copy and modify files
        def sourceArtifact = new File("$localMavenRepoPath/$groupPath/$sourceArtifactId")
        sourceArtifact.eachFileRecurse { File file ->
            String destinationFilePath = file.getPath().replace(sourceArtifactId, destinationArtifactId)
            File destinationFile = new File(destinationFilePath)

            // Ensure the destination directory exists before copying
            if (file.isDirectory()) {
                destinationFile.mkdirs()
            } else if (file.isFile()) {
                // Modify the contents of text files if they are XML, POM, or module files
                if (destinationFilePath.endsWith('.xml') || destinationFilePath.endsWith('.pom') || destinationFilePath.endsWith('.module')) {
                    String content = file.text.replace(sourceArtifactId, destinationArtifactId)
                    new File(destinationFilePath).write(content)
                } else {
                    // Else, copy the file as is and rename it
                    copy {
                        from file.path
                        into destinationFile.parentFile
                        rename { String fileName ->
                            return fileName.replace(sourceArtifactId, destinationArtifactId)
                        }
                    }
                }
            }
        }
    }
}
