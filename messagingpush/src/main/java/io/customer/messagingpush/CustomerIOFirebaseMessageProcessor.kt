package io.customer.messagingpush

import android.content.Context
import com.google.firebase.messaging.RemoteMessage
import io.customer.messagingpush.util.PushTrackingUtil
import io.customer.sdk.util.Logger

/**
 * Processor class to hold all message related tasks at a single place.
 */
internal interface CustomerIOFirebaseMessageProcessor {
    /**
     * Should be called whenever push notification is received. The method is
     * responsible for making sure that a CIO notification is processed only one
     * time even if the listeners are invoked multiple times.
     *
     * @param remoteMessage message received from FCM.
     * @param handleNotificationTrigger indicating if the local notification should be triggered
     * @return true if the notification was processed by the SDK either now or previously, false
     * if the notification is not from Customer.io or SDK is not yet initialized.
     */
    fun onMessageReceived(
        remoteMessage: RemoteMessage,
        handleNotificationTrigger: Boolean = true
    ): Boolean
}

/**
 * Native processor to process notification message directly using handler without verifying
 * details like messageId, etc.. The processor should only be used when we can guarantee that
 * a notification will be processed only one time.
 */
internal class CustomerIOFirebaseMessageNativeProcessor(
    private val context: Context
) : CustomerIOFirebaseMessageProcessor {
    override fun onMessageReceived(
        remoteMessage: RemoteMessage,
        handleNotificationTrigger: Boolean
    ): Boolean {
        val handler = CustomerIOPushNotificationHandler(remoteMessage = remoteMessage)
        return handler.handleMessage(context, handleNotificationTrigger)
    }
}

/**
 * Processor that makes processing notification easier for wrapper SDKs. It makes sure
 * that notifications are processed only when needed and returns correct results despite
 * multiple calls being made.
 */
internal class CustomerIOFirebaseMessageWrapperProcessor(
    private val context: Context,
    private val logger: Logger,
    private val moduleConfig: MessagingPushModuleConfig
) : CustomerIOFirebaseMessageProcessor {
    /**
     * Holds messageId of handled notifications against CIO delivery token.
     * This helps deciding between whether the notification was previously processed or not.
     */
    private val deliveryTokenToMessageId = mutableMapOf<String, MutableList<String>>()

    override fun onMessageReceived(
        remoteMessage: RemoteMessage,
        handleNotificationTrigger: Boolean
    ): Boolean {
        val cioDeliveryToken = remoteMessage.data[PushTrackingUtil.DELIVERY_TOKEN_KEY]
        // Skip processing the notification if there isn't any Customer.io delivery token
        if (cioDeliveryToken.isNullOrBlank()) {
            logger.info("Not a CIO push notification, skipped processing")
            return false
        }

        val currentMessageId = remoteMessage.messageId
        // FCM message id not available, process the notification only if allowed in the config
        // Read config docs for more details on the flag
        if (currentMessageId.isNullOrBlank() && moduleConfig.ignoreMessageWithInvalidId) {
            logger.info("CIO push notification received with invalid messageId. Make sure to process notification with valid messageId or disable ignoreMessageWithInvalidId in config")
            return false
        }

        val isHandled: Boolean
        // Make sure to process same notification only one time irrespective of number of callbacks
        // invoked for it
        synchronized(this) {
            val lastMessageIds = deliveryTokenToMessageId.getOrPut(cioDeliveryToken) {
                mutableListOf()
            }
            // Message ID is generated by FCM and helps us handling one notification only once
            // If the ID is null, we'll fallback to the behavior suggested by the config
            if (lastMessageIds.isEmpty() || !lastMessageIds.contains(currentMessageId)) {
                logger.info("CIO push notification processing with deliveryToken $cioDeliveryToken, messageId: $currentMessageId")
                val handler = CustomerIOPushNotificationHandler(remoteMessage = remoteMessage)
                isHandled = handler.handleMessage(context, handleNotificationTrigger)
                if (!currentMessageId.isNullOrBlank()) {
                    lastMessageIds.add(currentMessageId)
                }
            } else {
                logger.info("CIO push notification already processed with deliveryToken $cioDeliveryToken, messageId: $currentMessageId")
                isHandled = true
            }
        }
        return isHandled
    }
}
