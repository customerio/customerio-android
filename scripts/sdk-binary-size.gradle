import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import io.customer.android.Configurations

// Array of module names for evaluating SDK binary size
final List<String> targetModules = ['tracking', 'messagingpush', 'messaginginapp']
// Output file name for the combined report
final String sdkSizeReportFileName = 'sdk-binary-size.json'
// Unit used for generating binary size report
final String sdkSizeUnit = 'MB'

// Task to generate combined report of binary sizes of all SDK modules
// The report is generated in JSON format using apkscale plugin and is saved to
// `$buildDir/sdk-binary-size.json` by default
// This task can be run locally by executing `./gradlew generateSdkSizeReport`
// Run `./gradlew generateSdkSizeReport -PsaveReportTo=<saveReportTo>` to specify custom directory
// to save the report
tasks.register("generateSdkSizeReport") {
    // List all task dependencies for each library module
    ArrayList<String> taskDependencies = targetModules.collect { String moduleName ->
        ":$moduleName:measureSize"
    }
    // Add the republishing task as the first dependency as temporary workaround to make it work locally
    if (System.getenv('IS_DEVELOPMENT') == 'true') {
        // taskDependencies.add(0, ':republishTrackingModuleAsSdk')
    }
    dependsOn(taskDependencies)

    doLast {
        JsonSlurper jsonSlurper = new JsonSlurper()
        Map<String, Object> reports = new HashMap<>()

        // Iterate over the target modules and read the apkscale report for each
        project.subprojects.findAll { Project subproject ->
            targetModules.contains(subproject.name)
        }.each { Project subproject ->
            println "apkscale directory exists: ${subproject.file('build/apkscale').exists()}"
            File buildGradle = subproject.file('build/apkscale/build.gradle')
            if (buildGradle.exists()) {
                println 'sdk/build/apkscale/build.gradle exists'
                println buildGradle.text
                println '===================='
            } else {
                println 'sdk/build/apkscale/build.gradle does not exist'
            }

            // Get the path to the apkscale report for the module
            File jsonFile = subproject.file('build/apkscale/build/outputs/reports/apkscale.json')
            println "Processing report for ${subproject.name} at ${project.relativePath(jsonFile)}"

            // Parse the JSON file and extract module name and its binary size
            if (jsonFile.exists()) {
                println 'Raw Text:'
                println jsonFile.text
                println 'Raw JSON:'
                println jsonSlurper.parseText(jsonFile.text)
                def output = jsonSlurper.parseText(jsonFile.text).get(0)
                reports.put(subproject.name, output.size)
            } else {
                println "apkscale.json not found for ${subproject.name}"
            }
        }

        // Output directory for the combined report, default to `build` directory
        String outputDirectory = project.hasProperty('saveReportTo')
                ? project.getProperty('saveReportTo')
                : "$buildDir"
        // Create a combined report of all the individual reports
        File finalReport = project.file("$outputDirectory/$sdkSizeReportFileName")
        // Create parent directories if they do not exist
        finalReport.parentFile.mkdirs()
        // Write the combined report to output file as pretty printed JSON
        finalReport.text = new JsonBuilder(reports).toPrettyString()

        println "SDK binary size report successfully generated and saved to ${finalReport.canonicalPath}"
    }
}

// Task to compare the generated SDK binary size report with an existing report
// This task can be run locally by executing `./gradlew compareSdkSizeReports`
// Run `./gradlew compareSdkSizeReports -PcompareWithDir=<compareWithDir>` to specify custom
// directory for last recorded report to compare with
tasks.register('compareSdkSizeReports') {
    // Ensure the comparison runs after the generation of the latest report
    dependsOn([':generateSdkSizeReport'])

    doLast {
        // Allow specifying custom directory for existing report to compare with the reports
        // generated using CI for PRs that are not merged yet
        String existingReportDirectory = project.hasProperty('compareWithDir')
                ? project.getProperty('compareWithDir')
                : 'reports'
        // Read and validate the existing and generated reports for comparison
        File existingReportFile = new File("$existingReportDirectory/$sdkSizeReportFileName")
        if (!existingReportFile.exists()) {
            println "Existing report not found at ${existingReportFile.canonicalPath}"
            throw new GradleException('Failed to find existing report for comparison')
        }
        File generatedReportFile = new File("$buildDir/$sdkSizeReportFileName")
        if (!generatedReportFile.exists()) {
            println "Generated report not found at ${generatedReportFile.canonicalPath}"
            throw new GradleException('Failed to find generated report for comparison')
        }

        // Read the existing and generated reports for comparison
        JsonSlurper jsonSlurper = new JsonSlurper()
        def existingReport = jsonSlurper.parse(existingReportFile)
        def generatedReport = jsonSlurper.parse(generatedReportFile)

        // Flag to indicate if any changes were detected in the comparison
        Boolean changesDetected = false
        StringBuilder output = new StringBuilder()

        // Generate a markdown table for the comparison report
        output << '| Module | Variant | Last Recorded Size | Current Size | Change in Size |\n'
        output << '| ------ | ------- | ----------------- | ----------- | ----------- |\n'

        // Closure to parse size string and extract the number
        Closure<Float> parseSize = { sizeStr ->
            sizeStr.replace(sdkSizeUnit, '').trim() as float
        }

        // Closure to compare the sizes of a module and variant
        Closure<StringBuilder> compareReport = { String moduleName, String variant ->
            // Get the size of the module and variant from existing and generated reports
            def existingSize = existingReport[moduleName]?[variant]
            def generatedSize = generatedReport[moduleName]?[variant]

            // Parse the size strings to extract comparable numbers
            float existingSizeAsNumber = existingSize ? parseSize(existingSize) : 0
            float generatedSizeAsNumber = generatedSize ? parseSize(generatedSize) : 0

            String sizeChangeSummary
            if (existingSizeAsNumber != generatedSizeAsNumber) {
                // Calculate the difference in size and format it with the unit
                changesDetected = true
                float changeInSize = generatedSizeAsNumber - existingSizeAsNumber
                String changeInSizeWithUnit = "${String.format("%.2f", changeInSize)}${sdkSizeUnit}"
                sizeChangeSummary = changeInSize > 0 ? "⬆️ +$changeInSizeWithUnit" : "⬇️ $changeInSizeWithUnit"
            } else {
                // If the sizes are the same, indicate no change
                sizeChangeSummary = '✅ No Change'
            }
            // Append the comparison result to the output table
            output << "| `$moduleName` | `$variant` | `${existingSize}` | `${generatedSize}` | $sizeChangeSummary |\n"
        }

        // Iterate over the target modules and compare the sizes of universal variant,
        // as we are not tracking multiple abi variants for now
        targetModules.forEach { String moduleName ->
            compareReport(moduleName, 'universal')
        }

        // If no changes were detected, update the output to indicate no changes
        if (!changesDetected) {
            output = new StringBuilder()
            output << 'No changes detected in SDK binary size. ✅\n'
        }

        // Output file for the comparison report at same location as the generated report
        File comparisonOutputFile = new File("$buildDir/sdk-binary-comparison.md")
        // Write comparison results to the specified output file
        comparisonOutputFile.text = output.toString()

        println "Comparison completed. Results saved to: ${comparisonOutputFile.canonicalPath}"
    }
}

// This runs only in development mode locally and not in CI
// This is temporary and will be removed once tracking module is placed in same as its artifactId
//
// Republish the `tracking` module to `sdk` as a temporary workaround to track binary size
// The tracking module exists in directory named 'sdk', we need to republish 'tracking' as 'sdk'
// so apkscale can locate it locally
tasks.register("republishTrackingModuleAsSdk") {
    doLast {
        Boolean isDevelopment = System.getenv('IS_DEVELOPMENT') == 'true'
        if (!isDevelopment) {
            println 'Skipping republishing of the tracking module as SDK'
            return
        }

        println 'Republishing the tracking module as SDK'

        String localMavenRepoPath = "${System.getProperty('user.home')}/.m2/repository"
        String groupPath = Configurations.artifactGroup.replace('.', '/')
        String sourceArtifactId = 'tracking'
        String destinationArtifactId = 'sdk'

        // Recursively copy and modify files
        def sourceArtifact = new File("$localMavenRepoPath/$groupPath/$sourceArtifactId")
        sourceArtifact.eachFileRecurse { File file ->
            String destinationFilePath = file.getPath().replace(sourceArtifactId, destinationArtifactId)
            File destinationFile = new File(destinationFilePath)

            // Ensure the destination directory exists before copying
            if (file.isDirectory()) {
                destinationFile.mkdirs()
            } else if (file.isFile()) {
                // Modify the contents of text files if they are XML, POM, or module files
                if (destinationFilePath.endsWith('.xml') || destinationFilePath.endsWith('.pom') || destinationFilePath.endsWith('.module')) {
                    String content = file.text.replace(sourceArtifactId, destinationArtifactId)
                    new File(destinationFilePath).write(content)
                } else {
                    // Else, copy the file as is and rename it
                    copy {
                        from file.path
                        into destinationFile.parentFile
                        rename { String fileName ->
                            return fileName.replace(sourceArtifactId, destinationArtifactId)
                        }
                    }
                }
            }
        }
    }
}
